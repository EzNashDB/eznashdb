{% extends "base.html" %}

{% load static %}

{% block extra_media_top %}
    <link rel="stylesheet" href="{% static 'eznashdb/css/shuls.css' %}">
{% endblock extra_media_top %}

{% block content %}
    <div class="row h-100" x-data="{ showHelpText: false }">
        <div class="col h-100 d-flex flex-column">
            <div class="row mb-1">
                <div class="col-6">
                    <h4>Search Shuls</h4>
                </div>
                <div class="col-6 d-flex flex-column align-items-end">
                    <span class="text-nowrap">
                        <button type="button"
                                x-on:click="showHelpText = ! showHelpText"
                                class="btn btn-info btn-sm">
                            <i class="fa-solid fa-question"></i>
                            <span x-text="showHelpText ? 'Hide' : 'Show'">Show</span> help text
                        </button>
                    </span>
                </div>
            </div>
            <div class="row mb-3 shul-filters-row">
                <div class="col-12 h-100 shadow-scroll">
                    <div class="shadow-scroll__shadow-wrapper">
                        <div class="shadow-scroll__shadow shadow-scroll__top-shadow"></div>
                        <div class="shadow-scroll__shadow shadow-scroll__bottom-shadow"></div>
                        <div class="shadow-scroll__scroll-box shadow-scroll__scroll-box-padded"></div>
                    </div>
                    {% include "eznashdb/includes/shul_filters.html" %}
                </div>
            </div>
            <div class="row flex-grow-1 map-row">
                <div class="col-6">
                    <div id="shuls-js-loader-wrapper">{% include "eznashdb/includes/shuls_js_loader.html" %}</div>
                    <div class="border rounded h-100 position-relative">
                        <span class="spinner-overlay bg-secondary w-100 h-100 rounded text-center d-flex align-items-center opacity-0">
                            <div class="flex-grow-1 text-center">
                                <span class="spinner-border spinner-border-lg"
                                      style="width: 3rem;
                                             height: 3rem"
                                      role="status">
                                    <span class="visually-hidden">Loading...</span>
                                </span>
                            </div>
                        </span>
                        <div id="shuls-map" class="h-100"></div>
                    </div>
                </div>
                {% comment %} new map {% endcomment %}
                <div class="col-6">
                    <div id="shuls-js-loader-wrapper">{% include "eznashdb/includes/shuls_js_loader.html" %}</div>
                    <div class="border rounded h-100 position-relative">
                        <span class="spinner-overlay bg-secondary w-100 h-100 rounded text-center d-flex align-items-center opacity-0">
                            <div class="flex-grow-1 text-center">
                                <span class="spinner-border spinner-border-lg"
                                      style="width: 3rem;
                                             height: 3rem"
                                      role="status">
                                    <span class="visually-hidden">Loading...</span>
                                </span>
                            </div>
                        </span>
                        <div id="new-shuls-map" class="h-100"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
{% endblock %}

{% block extra_media_bottom %}
    {{ block.super }}
    <script defer>
        (function () {
        // Utilities for URL param management
        const updateURLParams = (params) => {
            const url = new URL(window.location.href);
            for (const key in params) url.searchParams.set(key, params[key]);
            history.replaceState({}, "", url.toString());
        };
        const deleteURLParams = (params) => {
            const url = new URL(window.location.href);
            params.forEach((param) => url.searchParams.delete(param));
            history.replaceState({}, "", url.toString());
        };

        const updateURLLocationParams = (map) => {
            const center = map.getCenter();
            updateURLParams({
            lat: center.lat,
            lon: center.lng,
            zoom: map.getZoom(),
            });
        };

        // Map initialization when DOM is ready
        document.addEventListener("DOMContentLoaded", () => {
            const urlParams = new URLSearchParams(window.location.search);
            const mapId = "new-shuls-map";
            const startLat = parseFloat(urlParams.get("lat")) || 20;
            const startLon = parseFloat(urlParams.get("lon")) || 10;
            const startZoom = parseInt(urlParams.get("zoom"), 10) || 2;

            const map = L.map(mapId, {
                center: [startLat, startLon],
                zoom: startZoom,
                scrollWheelZoom: true,
                worldCopyJump: true,
                minZoom: 1,
                zoomControl: false,
            });

            L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?", {
            attribution:
                '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            }).addTo(map);

            L.control.zoom({ position: "bottomleft" }).addTo(map);
            document.getElementById(mapId).classList.add("rounded");

            map.whenReady(() => {
            // small delay allows CSS/layout to finish
                setTimeout(() => map.invalidateSize(), 150);
            });

            // ---- Shuls-found control (topright) ----
            const shulsFoundControl = L.control({ position: "topright" });
            shulsFoundControl.onAdd = function () {
            const container = L.DomUtil.create("div", "shuls-found-control");
            container.style.cursor = "initial";
            const shulCount = {{object_list.count}};
            const shulCountMsg = `${shulCount} ${shulCount === 1 ? "shul" : "shuls"} found`;
            container.innerHTML = `<div class="fw-normal fs-5 opacity-75"><span class="badge bg-dark">${shulCountMsg}</span></div>`;
            L.DomEvent.disableClickPropagation(container);
            L.DomEvent.disableScrollPropagation(container);
            return container;
            };
            shulsFoundControl.addTo(map);

            // Icon
            const myIcon = L.icon({
                iconUrl: "{% static 'eznashdb/images/marker-icon.png' %}",
                shadowUrl: "{% static 'eznashdb/images/marker-shadow.png' %}",
                iconSize: [25, 41],
                iconAnchor: [13, 41],
                popupAnchor: [0, -34],
            });

            // Read selectedPin from URL once
            const selectedPinIdFromURL = urlParams.get("selectedPin");

            // Storage for popups and markers so we can easily replace later (HTMX usage)
            const popupHtmlMap = {};      // keyed by shul id (string) -> html string
            const markersByPopupId = {};  // keyed by popupId (string like '123', '+123', '-123') -> marker instance

            // Create marker cluster group (or LayerGroup if you don't use clustering)
            const markersLayer = L.markerClusterGroup();
            // Exported-ish helper functions (kept local here, but easy to expose globally if you want)
            const api = {
            addMarker: (shulId, lat, lon, popupId) => {
                const popupHtml = popupHtmlMap[String(shulId)];
                if (!popupHtml) {
                console.warn("No popup HTML for shulId", shulId);
                }
                const marker = L.marker([lat, lon], { icon: myIcon });

                // Bind popup with metadata in options for easy lookup later
                marker.bindPopup(popupHtml || "", {
                className: "shul-popup",
                closeButton: false,
                shulId: shulId,
                popupId: popupId,
                });

                // When popup opens, wire the close button (popup DOM is recreated each open)
                marker.on("popupopen", (e) => {
                const popupEl = e.popup.getElement();
                if (!popupEl) return;
                const closeBtn = popupEl.querySelector(".shul-popup-close");
                if (closeBtn) {
                    // Use e.popup._source which is the marker that opened this popup
                    closeBtn.addEventListener("click", (ev) => {
                    ev.preventDefault();
                    if (e.popup && e.popup._source) e.popup._source.closePopup();
                    });
                }
                });

                markersLayer.addLayer(marker);
                markersByPopupId[String(popupId)] = marker;

                // If this marker corresponds to the requested selectedPin, return it for opening after the layer is added to map
                return marker;
            },

            clearMarkers: () => {
                markersLayer.clearLayers();
                for (const k in markersByPopupId) delete markersByPopupId[k];
            },

            // Replace markers (intended for HTMX responses). Accepts an array of objects { id, lat, lon, popupId }
            // This is a convenience; your HTMX success handler can call api.clearMarkers(); then loop and api.addMarker(...)
            replaceMarkers: (markersData) => {
                api.clearMarkers();
                markersData.forEach((md) => {
                api.addMarker(md.id, md.lat, md.lon, md.popupId);
                });
                // if you need to re-add the cluster to the map, ensure map.addLayer(markersLayer) was called earlier
            },

            markersLayer,
            markersByPopupId,
            popupHtmlMap,
            };

            // -----------------------------------------------------------------------
            // Server-rendered popup HTML for each shul
            // We insert each popup HTML into popupHtmlMap keyed by the shul id (string).
            // Keep the server-side template rendering here as before.
            // -----------------------------------------------------------------------
            {% for shul in object_list %}
                popupHtmlMap["{{ shul.id }}"] = `{% include "eznashdb/includes/shul_popup.html" %}`;
                // Add the three wrap-around variants (original, -360, +360)
                (function () {
                const id = {{ shul.id }};
                const lat = parseFloat({{ shul.latitude }});
                const lon = parseFloat({{ shul.longitude }});
                // original
                api.addMarker(id, lat, lon, String(id));
                // wrap-around west
                api.addMarker(id, lat, lon - 360, "-" + String(id));
                // wrap-around east
                api.addMarker(id, lat, lon + 360, "+" + String(id));
                })();
            {% endfor %}

            // Add marker layer to map (do this once after all markers added)
            map.addLayer(markersLayer);

            // If URL requested a selectedPin, open it. If using clusters, zoomToShowLayer is used to ensure visibility.
            if (selectedPinIdFromURL) {
            const target = api.markersByPopupId[String(selectedPinIdFromURL)];
            if (target) {
                // if markersLayer is a MarkerClusterGroup, prefer zoomToShowLayer
                if (typeof markersLayer.zoomToShowLayer === "function") {
                markersLayer.zoomToShowLayer(target, () => target.openPopup());
                } else {
                // ensure marker is on the map and then open
                setTimeout(() => target.openPopup(), 0);
                }
            }
            }

            // Keep URL in sync with map movements and popup state
            map.on("moveend", () => updateURLLocationParams(map));
            map.on("zoomend", () => updateURLLocationParams(map));

            map.on("popupopen", (e) => {
            // store the shul id of the open popup in the URL
            if (e.popup && e.popup.options && e.popup.options.shulId !== undefined) {
                updateURLParams({ selectedPin: e.popup.options.shulId });
            }
            });

            map.on("popupclose", () => {
                deleteURLParams(["selectedPin"]);
            });

            // Expose limited API for HTMX usage: window.SHUL_MAP_API.replaceMarkers([...])
            // replaceMarkers should accept an array of objects: { id, lat, lon, popupId } and can be called when new HTMX results arrive.
            window.SHUL_MAP_API = window.SHUL_MAP_API || {};
            window.SHUL_MAP_API._internal = api; // internal maps and helpers
            window.SHUL_MAP_API.replaceMarkers = (markersData) => {
            // example markersData item: { id: 123, lat: 51.5, lon: -0.09, popupId: '123' }
            api.clearMarkers();
            markersData.forEach((md) => {
                // Ensure popupHtmlMap has html for the shul id; if you are rendering popup html on HTMX response,
                // you should update popupHtmlMap accordingly before calling replaceMarkers (or include popupHtml in md)
                api.addMarker(md.id, md.lat, md.lon, md.popupId);
            });
            // If markers layer wasn't added (rare), ensure it's on the map
            if (!map.hasLayer(markersLayer)) map.addLayer(markersLayer);
            };

            // --- end DOMContentLoaded handler ---
        });
        })();
    </script>
    <script defer src="{% static 'dist/shulsMap.js' %}"></script>
{% endblock extra_media_bottom %}
